package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.Disabled;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorController;
import com.qualcomm.robotcore.hardware.DigitalChannel;
import com.qualcomm.robotcore.util.ElapsedTime;

@com.qualcomm.robotcore.eventloop.opmode.TeleOp(name="TeleOpTest", group="Robot")

public class Manual extends LinearOpMode {
    Hardware robot = Hardware.getInstance();
    private ElapsedTime run = new ElapsedTime();
    private DcMotor liftMotor = null;
    double liftPower;
    boolean touchSensorPressed = false;
    boolean movingByEncoder = false;

    @Override
    public void runOpMode()  {
        double drive = 0;
        double turn = 0;
        double max;
        double strafe = 0;
        boolean intake = false;
        boolean pressingrt = false;
        boolean pressinglt = false;
        boolean moveForward = false;
        boolean moveBackward = false;
        boolean pressed = false;

        robot.init(hardwareMap);

        robot.arm.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        robot.arm.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        liftMotor = hardwareMap.get(DcMotor.class, "arm motor");
        liftMotor.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);

        waitForStart();

        while(opModeIsActive())
        {
            drive = -gamepad1.left_stick_y;
            turn = gamepad1.right_stick_x;
            strafe = gamepad1.left_stick_x;

            int enposition = robot.arm.getCurrentPosition();
            telemetry.addData("Encoder Position: ", enposition);
            telemetry.addData("Duck Servo Pos: ", robot.sRetract.getPosition());
            //telemetry.update();

            //move carousel servo with bumpers. right bumper for red, left for blue
            if((gamepad2.left_bumper)) {
                robot.duckPower(-0.9);
            }
            else if ((gamepad2.right_bumper)) {
                robot.duckPower(0.9);
            }
            else {
                robot.duckPower(0);
            }

            if(gamepad2.y) {
                robot.setsRetract(0);
            }

            //move servo claw in and out to contain freight
            if (gamepad2.b) {    //closes completely
                robot.setsClawPosition(0.07);
            }
            if(gamepad2.a) { //open
                robot.setsClawPosition(0.36);
            }
            if(gamepad2.x) { //closes halfway
                robot.setsClawPosition(0.15);
            }

            //move the intake noodles
            robot.intakeSetPower(-gamepad2.left_stick_y);

            //ARM AND TOUCH SENSOR!!
            // Digital Input and Telemetry
            if (robot.digitalTouch.getState() != true) {
                telemetry.addData("Digital Touch: ", "Pressed");
                touchSensorPressed = true;              // this value to remain until the lift starts up
                liftMotor.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
                liftMotor.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
            }
            else {
                telemetry.addData("Digital Touch: ", "Not Pressed    ");
            }

            // lift motor control so that it only goes up after touch sensor is pressed
            if(!movingByEncoder) {
                if (!touchSensorPressed ) {    // touch sensor not pressed so allow lift to work in both directions
                    liftPower = -gamepad2.right_stick_y;
                } else if (touchSensorPressed && -gamepad2.right_stick_y < 0) {  // joystick set to go up only
                    liftPower = -gamepad2.right_stick_y;
                    touchSensorPressed = false;
                } else {                      // touch sensor has been pressed so stop motor until the motor is given an up value
                    liftPower = 0;
                }

                // now set the lift motor to the power determined above
                liftMotor.setPower(liftPower);
            }

            telemetry.addData("MotorPower: ",liftPower);
            telemetry.addData("EncoderValue: ",liftMotor.getCurrentPosition());
            telemetry.addData("TargetPosition: ", liftMotor.getTargetPosition());
            telemetry.update();



            //GAMEPAD 1

            //decrease forward speed slowly with right trigger
            if ((gamepad1.right_trigger > 0.1) && !pressingrt) {
                if (moveForward) {
                    robot.setPower(0.35, 0.35, 0.35, 0.35);

                    int counter = 0;
                    while (gamepad1.right_trigger > 0.1) {
                        drive = 1-(counter*0.5);
                        counter++;
                    }
                    moveForward = false;
                }
                else {
                    moveForward = true;
                    robot.setPower(-0.35,-0.35,-0.35,-0.35);
                    drive = -0.35;
                }
                pressingrt = true;

            } else if (!(gamepad1.right_trigger > 0.1)) {
                //action
                pressingrt = false;
            }

            //decrease backward speed slowly with left trigger
            if ((gamepad1.left_trigger > 0.1) && !pressinglt) {
                if (moveBackward) {
                    robot.setPower(-0.35, -0.35, -0.35, -0.35);

                    int counter = 0;
                    while (gamepad1.left_trigger > 0.1) {
                        drive = -(1- (counter*0.5));
                        counter++;
                    }
                    moveBackward = false;
                }
                else {
                    moveBackward = true;
                    robot.setPower(0.35,0.35,0.35,0.35);
                    drive = 0.35;
                }
                pressinglt = true;

            } else if (!(gamepad1.left_trigger > 0.1)) {
                //action
                pressinglt = false;
            }

            //movement
            max = Math.max(Math.abs(drive - strafe - turn), Math.max(Math.abs(drive + strafe - turn),
                    Math.max(Math.abs(drive + strafe + turn), Math.abs(drive + turn - strafe))));
            if (max < robot.maxSpeed) {
                robot.setPower(drive - strafe - turn, drive + strafe - turn,
                        drive + strafe + turn, drive + turn - strafe);
            }
            else {
                double scaleFactor = max / robot.maxSpeed;
                robot.setPower((drive - strafe - turn) * scaleFactor, (drive + strafe - turn) * scaleFactor,
                        (drive + strafe + turn) * scaleFactor, (drive + turn - strafe) * scaleFactor);
            }

        }//close while loop for opmode is active
    }//close opmode
}//close class
